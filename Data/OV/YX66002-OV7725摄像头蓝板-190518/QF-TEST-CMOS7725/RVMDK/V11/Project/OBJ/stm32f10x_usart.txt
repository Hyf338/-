; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\stm32f10x_usart.o --depend=..\OBJ\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\USER\INC -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\stm32f10x_usart.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;129      */
;;;130    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  4604              MOV      r4,r0
;;;132      /* Check the parameters */
;;;133      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;134    
;;;135      if (USARTx == USART1)
000004  48fb              LDR      r0,|L1.1012|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L1.30|
;;;136      {
;;;137        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0388              LSLS     r0,r1,#14
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;138        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f4080          MOV      r0,#0x4000
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001c  e032              B        |L1.132|
                  |L1.30|
;;;139      }
;;;140      else if (USARTx == USART2)
00001e  48f6              LDR      r0,|L1.1016|
000020  4284              CMP      r4,r0
000022  d109              BNE      |L1.56|
;;;141      {
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0448              LSLS     r0,r1,#17
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002c  2100              MOVS     r1,#0
00002e  f44f3000          MOV      r0,#0x20000
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
000036  e025              B        |L1.132|
                  |L1.56|
;;;144      }
;;;145      else if (USARTx == USART3)
000038  48f0              LDR      r0,|L1.1020|
00003a  4284              CMP      r4,r0
00003c  d109              BNE      |L1.82|
;;;146      {
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  0488              LSLS     r0,r1,#18
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000046  2100              MOVS     r1,#0
000048  f44f2080          MOV      r0,#0x40000
00004c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000050  e018              B        |L1.132|
                  |L1.82|
;;;149      }    
;;;150      else if (USARTx == UART4)
000052  48eb              LDR      r0,|L1.1024|
000054  4284              CMP      r4,r0
000056  d109              BNE      |L1.108|
;;;151      {
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000058  2101              MOVS     r1,#1
00005a  04c8              LSLS     r0,r1,#19
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000060  2100              MOVS     r1,#0
000062  f44f2000          MOV      r0,#0x80000
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
00006a  e00b              B        |L1.132|
                  |L1.108|
;;;154      }    
;;;155      else
;;;156      {
;;;157        if (USARTx == UART5)
00006c  48e5              LDR      r0,|L1.1028|
00006e  4284              CMP      r4,r0
000070  d108              BNE      |L1.132|
;;;158        { 
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000072  2101              MOVS     r1,#1
000074  0508              LSLS     r0,r1,#20
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
00007a  2100              MOVS     r1,#0
00007c  f44f1080          MOV      r0,#0x100000
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.132|
;;;161        }
;;;162      }
;;;163    }
000084  bd10              POP      {r4,pc}
;;;164    
                          ENDP

                  USART_Init PROC
;;;175      */
;;;176    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000086  e92d47f0          PUSH     {r4-r10,lr}
;;;177    {
00008a  b086              SUB      sp,sp,#0x18
00008c  4604              MOV      r4,r0
00008e  460d              MOV      r5,r1
;;;178      uint32_t tmpreg = 0x00, apbclock = 0x00;
000090  2600              MOVS     r6,#0
000092  2700              MOVS     r7,#0
;;;179      uint32_t integerdivider = 0x00;
000094  bf00              NOP      
;;;180      uint32_t fractionaldivider = 0x00;
000096  46b1              MOV      r9,r6
;;;181      uint32_t usartxbase = 0;
000098  46b2              MOV      r10,r6
;;;182      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;183      /* Check the parameters */
;;;184      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;185      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;186      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;187      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;188      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;189      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;190      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;191      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;192      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
00009a  89a8              LDRH     r0,[r5,#0xc]
00009c  b100              CBZ      r0,|L1.160|
;;;193      {
;;;194        assert_param(IS_USART_123_PERIPH(USARTx));
00009e  bf00              NOP      
                  |L1.160|
;;;195      }
;;;196    
;;;197      usartxbase = (uint32_t)USARTx;
0000a0  46a2              MOV      r10,r4
;;;198    
;;;199    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;200      tmpreg = USARTx->CR2;
0000a2  8a26              LDRH     r6,[r4,#0x10]
;;;201      /* Clear STOP[13:12] bits */
;;;202      tmpreg &= CR2_STOP_CLEAR_Mask;
0000a4  f64c70ff          MOV      r0,#0xcfff
0000a8  4006              ANDS     r6,r6,r0
;;;203      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;204      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;205      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
0000aa  88e8              LDRH     r0,[r5,#6]
0000ac  4306              ORRS     r6,r6,r0
;;;206      
;;;207      /* Write to USART CR2 */
;;;208      USARTx->CR2 = (uint16_t)tmpreg;
0000ae  8226              STRH     r6,[r4,#0x10]
;;;209    
;;;210    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;211      tmpreg = USARTx->CR1;
0000b0  89a6              LDRH     r6,[r4,#0xc]
;;;212      /* Clear M, PCE, PS, TE and RE bits */
;;;213      tmpreg &= CR1_CLEAR_Mask;
0000b2  f64e10f3          MOV      r0,#0xe9f3
0000b6  4006              ANDS     r6,r6,r0
;;;214      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;215      /* Set the M bits according to USART_WordLength value */
;;;216      /* Set PCE and PS bits according to USART_Parity value */
;;;217      /* Set TE and RE bits according to USART_Mode value */
;;;218      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000b8  88a8              LDRH     r0,[r5,#4]
0000ba  8929              LDRH     r1,[r5,#8]
0000bc  4308              ORRS     r0,r0,r1
0000be  8969              LDRH     r1,[r5,#0xa]
0000c0  4308              ORRS     r0,r0,r1
0000c2  4306              ORRS     r6,r6,r0
;;;219                USART_InitStruct->USART_Mode;
;;;220      /* Write to USART CR1 */
;;;221      USARTx->CR1 = (uint16_t)tmpreg;
0000c4  81a6              STRH     r6,[r4,#0xc]
;;;222    
;;;223    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;224      tmpreg = USARTx->CR3;
0000c6  8aa6              LDRH     r6,[r4,#0x14]
;;;225      /* Clear CTSE and RTSE bits */
;;;226      tmpreg &= CR3_CLEAR_Mask;
0000c8  f64f40ff          MOV      r0,#0xfcff
0000cc  4006              ANDS     r6,r6,r0
;;;227      /* Configure the USART HFC -------------------------------------------------*/
;;;228      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;229      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000ce  89a8              LDRH     r0,[r5,#0xc]
0000d0  4306              ORRS     r6,r6,r0
;;;230      /* Write to USART CR3 */
;;;231      USARTx->CR3 = (uint16_t)tmpreg;
0000d2  82a6              STRH     r6,[r4,#0x14]
;;;232    
;;;233    /*---------------------------- USART BRR Configuration -----------------------*/
;;;234      /* Configure the USART Baud Rate -------------------------------------------*/
;;;235      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000d4  a801              ADD      r0,sp,#4
0000d6  f7fffffe          BL       RCC_GetClocksFreq
;;;236      if (usartxbase == USART1_BASE)
0000da  4654              MOV      r4,r10
0000dc  48c5              LDR      r0,|L1.1012|
0000de  4582              CMP      r10,r0
0000e0  d101              BNE      |L1.230|
;;;237      {
;;;238        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
0000e2  9f04              LDR      r7,[sp,#0x10]
0000e4  e000              B        |L1.232|
                  |L1.230|
;;;239      }
;;;240      else
;;;241      {
;;;242        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0000e6  9f03              LDR      r7,[sp,#0xc]
                  |L1.232|
;;;243      }
;;;244      
;;;245      /* Determine the integer part */
;;;246      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
0000e8  89a0              LDRH     r0,[r4,#0xc]
0000ea  f4104f00          TST      r0,#0x8000
0000ee  d008              BEQ      |L1.258|
;;;247      {
;;;248        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;249        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
0000f0  eb0700c7          ADD      r0,r7,r7,LSL #3
0000f4  eb001007          ADD      r0,r0,r7,LSL #4
0000f8  6829              LDR      r1,[r5,#0]
0000fa  0049              LSLS     r1,r1,#1
0000fc  fbb0f8f1          UDIV     r8,r0,r1
000100  e007              B        |L1.274|
                  |L1.258|
;;;250      }
;;;251      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;252      {
;;;253        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;254        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000102  eb0700c7          ADD      r0,r7,r7,LSL #3
000106  eb001007          ADD      r0,r0,r7,LSL #4
00010a  6829              LDR      r1,[r5,#0]
00010c  0089              LSLS     r1,r1,#2
00010e  fbb0f8f1          UDIV     r8,r0,r1
                  |L1.274|
;;;255      }
;;;256      tmpreg = (integerdivider / 100) << 4;
000112  2064              MOVS     r0,#0x64
000114  fbb8f0f0          UDIV     r0,r8,r0
000118  0106              LSLS     r6,r0,#4
;;;257    
;;;258      /* Determine the fractional part */
;;;259      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
00011a  0930              LSRS     r0,r6,#4
00011c  2164              MOVS     r1,#0x64
00011e  fb018910          MLS      r9,r1,r0,r8
;;;260    
;;;261      /* Implement the fractional part in the register */
;;;262      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000122  89a0              LDRH     r0,[r4,#0xc]
000124  f4104f00          TST      r0,#0x8000
000128  d009              BEQ      |L1.318|
;;;263      {
;;;264        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
00012a  2132              MOVS     r1,#0x32
00012c  eb0100c9          ADD      r0,r1,r9,LSL #3
000130  2164              MOVS     r1,#0x64
000132  fbb0f0f1          UDIV     r0,r0,r1
000136  f0000007          AND      r0,r0,#7
00013a  4306              ORRS     r6,r6,r0
00013c  e008              B        |L1.336|
                  |L1.318|
;;;265      }
;;;266      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;267      {
;;;268        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
00013e  2132              MOVS     r1,#0x32
000140  eb011009          ADD      r0,r1,r9,LSL #4
000144  2164              MOVS     r1,#0x64
000146  fbb0f0f1          UDIV     r0,r0,r1
00014a  f000000f          AND      r0,r0,#0xf
00014e  4306              ORRS     r6,r6,r0
                  |L1.336|
;;;269      }
;;;270      
;;;271      /* Write to USART BRR */
;;;272      USARTx->BRR = (uint16_t)tmpreg;
000150  8126              STRH     r6,[r4,#8]
;;;273    }
000152  b006              ADD      sp,sp,#0x18
000154  e8bd87f0          POP      {r4-r10,pc}
;;;274    
                          ENDP

                  USART_StructInit PROC
;;;280      */
;;;281    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000158  f44f5116          MOV      r1,#0x2580
;;;282    {
;;;283      /* USART_InitStruct members default value */
;;;284      USART_InitStruct->USART_BaudRate = 9600;
00015c  6001              STR      r1,[r0,#0]
;;;285      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
00015e  2100              MOVS     r1,#0
000160  8081              STRH     r1,[r0,#4]
;;;286      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000162  80c1              STRH     r1,[r0,#6]
;;;287      USART_InitStruct->USART_Parity = USART_Parity_No ;
000164  8101              STRH     r1,[r0,#8]
;;;288      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000166  210c              MOVS     r1,#0xc
000168  8141              STRH     r1,[r0,#0xa]
;;;289      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
00016a  2100              MOVS     r1,#0
00016c  8181              STRH     r1,[r0,#0xc]
;;;290    }
00016e  4770              BX       lr
;;;291    
                          ENDP

                  USART_ClockInit PROC
;;;301      */
;;;302    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000170  b510              PUSH     {r4,lr}
;;;303    {
;;;304      uint32_t tmpreg = 0x00;
000172  2200              MOVS     r2,#0
;;;305      /* Check the parameters */
;;;306      assert_param(IS_USART_123_PERIPH(USARTx));
;;;307      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;308      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;309      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;310      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;311      
;;;312    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;313      tmpreg = USARTx->CR2;
000174  8a02              LDRH     r2,[r0,#0x10]
;;;314      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;315      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000176  f24f03ff          MOV      r3,#0xf0ff
00017a  401a              ANDS     r2,r2,r3
;;;316      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;317      /* Set CLKEN bit according to USART_Clock value */
;;;318      /* Set CPOL bit according to USART_CPOL value */
;;;319      /* Set CPHA bit according to USART_CPHA value */
;;;320      /* Set LBCL bit according to USART_LastBit value */
;;;321      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00017c  880b              LDRH     r3,[r1,#0]
00017e  884c              LDRH     r4,[r1,#2]
000180  4323              ORRS     r3,r3,r4
000182  888c              LDRH     r4,[r1,#4]
000184  4323              ORRS     r3,r3,r4
000186  88cc              LDRH     r4,[r1,#6]
000188  4323              ORRS     r3,r3,r4
00018a  431a              ORRS     r2,r2,r3
;;;322                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;323      /* Write to USART CR2 */
;;;324      USARTx->CR2 = (uint16_t)tmpreg;
00018c  8202              STRH     r2,[r0,#0x10]
;;;325    }
00018e  bd10              POP      {r4,pc}
;;;326    
                          ENDP

                  USART_ClockStructInit PROC
;;;332      */
;;;333    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000190  2100              MOVS     r1,#0
;;;334    {
;;;335      /* USART_ClockInitStruct members default value */
;;;336      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000192  8001              STRH     r1,[r0,#0]
;;;337      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000194  8041              STRH     r1,[r0,#2]
;;;338      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000196  8081              STRH     r1,[r0,#4]
;;;339      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000198  80c1              STRH     r1,[r0,#6]
;;;340    }
00019a  4770              BX       lr
;;;341    
                          ENDP

                  USART_Cmd PROC
;;;350      */
;;;351    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
00019c  b121              CBZ      r1,|L1.424|
;;;352    {
;;;353      /* Check the parameters */
;;;354      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;355      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;356      
;;;357      if (NewState != DISABLE)
;;;358      {
;;;359        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;360        USARTx->CR1 |= CR1_UE_Set;
00019e  8982              LDRH     r2,[r0,#0xc]
0001a0  f4425200          ORR      r2,r2,#0x2000
0001a4  8182              STRH     r2,[r0,#0xc]
0001a6  e004              B        |L1.434|
                  |L1.424|
;;;361      }
;;;362      else
;;;363      {
;;;364        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;365        USARTx->CR1 &= CR1_UE_Reset;
0001a8  8982              LDRH     r2,[r0,#0xc]
0001aa  f64d73ff          MOV      r3,#0xdfff
0001ae  401a              ANDS     r2,r2,r3
0001b0  8182              STRH     r2,[r0,#0xc]
                  |L1.434|
;;;366      }
;;;367    }
0001b2  4770              BX       lr
;;;368    
                          ENDP

                  USART_ITConfig PROC
;;;387      */
;;;388    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
0001b4  b5f0              PUSH     {r4-r7,lr}
;;;389    {
;;;390      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
0001b6  2400              MOVS     r4,#0
0001b8  2500              MOVS     r5,#0
0001ba  2600              MOVS     r6,#0
;;;391      uint32_t usartxbase = 0x00;
0001bc  2300              MOVS     r3,#0
;;;392      /* Check the parameters */
;;;393      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;394      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;395      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;396      /* The CTS interrupt is not available for UART4 and UART5 */
;;;397      if (USART_IT == USART_IT_CTS)
0001be  f5a16710          SUB      r7,r1,#0x900
0001c2  3f6a              SUBS     r7,r7,#0x6a
0001c4  d100              BNE      |L1.456|
;;;398      {
;;;399        assert_param(IS_USART_123_PERIPH(USARTx));
0001c6  bf00              NOP      
                  |L1.456|
;;;400      }   
;;;401      
;;;402      usartxbase = (uint32_t)USARTx;
0001c8  4603              MOV      r3,r0
;;;403    
;;;404      /* Get the USART register index */
;;;405      usartreg = (((uint8_t)USART_IT) >> 0x05);
0001ca  f3c11442          UBFX     r4,r1,#5,#3
;;;406    
;;;407      /* Get the interrupt position */
;;;408      itpos = USART_IT & IT_Mask;
0001ce  f001051f          AND      r5,r1,#0x1f
;;;409      itmask = (((uint32_t)0x01) << itpos);
0001d2  2701              MOVS     r7,#1
0001d4  fa07f605          LSL      r6,r7,r5
;;;410        
;;;411      if (usartreg == 0x01) /* The IT is in CR1 register */
0001d8  2c01              CMP      r4,#1
0001da  d101              BNE      |L1.480|
;;;412      {
;;;413        usartxbase += 0x0C;
0001dc  330c              ADDS     r3,r3,#0xc
0001de  e004              B        |L1.490|
                  |L1.480|
;;;414      }
;;;415      else if (usartreg == 0x02) /* The IT is in CR2 register */
0001e0  2c02              CMP      r4,#2
0001e2  d101              BNE      |L1.488|
;;;416      {
;;;417        usartxbase += 0x10;
0001e4  3310              ADDS     r3,r3,#0x10
0001e6  e000              B        |L1.490|
                  |L1.488|
;;;418      }
;;;419      else /* The IT is in CR3 register */
;;;420      {
;;;421        usartxbase += 0x14; 
0001e8  3314              ADDS     r3,r3,#0x14
                  |L1.490|
;;;422      }
;;;423      if (NewState != DISABLE)
0001ea  b11a              CBZ      r2,|L1.500|
;;;424      {
;;;425        *(__IO uint32_t*)usartxbase  |= itmask;
0001ec  681f              LDR      r7,[r3,#0]
0001ee  4337              ORRS     r7,r7,r6
0001f0  601f              STR      r7,[r3,#0]
0001f2  e002              B        |L1.506|
                  |L1.500|
;;;426      }
;;;427      else
;;;428      {
;;;429        *(__IO uint32_t*)usartxbase &= ~itmask;
0001f4  681f              LDR      r7,[r3,#0]
0001f6  43b7              BICS     r7,r7,r6
0001f8  601f              STR      r7,[r3,#0]
                  |L1.506|
;;;430      }
;;;431    }
0001fa  bdf0              POP      {r4-r7,pc}
;;;432    
                          ENDP

                  USART_DMACmd PROC
;;;447      */
;;;448    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
0001fc  b510              PUSH     {r4,lr}
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;452      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;453      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;454      if (NewState != DISABLE)
0001fe  b11a              CBZ      r2,|L1.520|
;;;455      {
;;;456        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;457           DMAR bits in the USART CR3 register */
;;;458        USARTx->CR3 |= USART_DMAReq;
000200  8a83              LDRH     r3,[r0,#0x14]
000202  430b              ORRS     r3,r3,r1
000204  8283              STRH     r3,[r0,#0x14]
000206  e004              B        |L1.530|
                  |L1.520|
;;;459      }
;;;460      else
;;;461      {
;;;462        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;463           DMAR bits in the USART CR3 register */
;;;464        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000208  8a83              LDRH     r3,[r0,#0x14]
00020a  43cc              MVNS     r4,r1
00020c  b2a4              UXTH     r4,r4
00020e  4023              ANDS     r3,r3,r4
000210  8283              STRH     r3,[r0,#0x14]
                  |L1.530|
;;;465      }
;;;466    }
000212  bd10              POP      {r4,pc}
;;;467    
                          ENDP

                  USART_SetAddress PROC
;;;475      */
;;;476    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000214  8a02              LDRH     r2,[r0,#0x10]
;;;477    {
;;;478      /* Check the parameters */
;;;479      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;480      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;481        
;;;482      /* Clear the USART address */
;;;483      USARTx->CR2 &= CR2_Address_Mask;
000216  f64f73f0          MOV      r3,#0xfff0
00021a  401a              ANDS     r2,r2,r3
00021c  8202              STRH     r2,[r0,#0x10]
;;;484      /* Set the USART address node */
;;;485      USARTx->CR2 |= USART_Address;
00021e  8a02              LDRH     r2,[r0,#0x10]
000220  430a              ORRS     r2,r2,r1
000222  8202              STRH     r2,[r0,#0x10]
;;;486    }
000224  4770              BX       lr
;;;487    
                          ENDP

                  USART_WakeUpConfig PROC
;;;498      */
;;;499    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000226  8982              LDRH     r2,[r0,#0xc]
;;;500    {
;;;501      /* Check the parameters */
;;;502      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;503      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;504      
;;;505      USARTx->CR1 &= CR1_WAKE_Mask;
000228  f24f73ff          MOV      r3,#0xf7ff
00022c  401a              ANDS     r2,r2,r3
00022e  8182              STRH     r2,[r0,#0xc]
;;;506      USARTx->CR1 |= USART_WakeUp;
000230  8982              LDRH     r2,[r0,#0xc]
000232  430a              ORRS     r2,r2,r1
000234  8182              STRH     r2,[r0,#0xc]
;;;507    }
000236  4770              BX       lr
;;;508    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;517      */
;;;518    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000238  b121              CBZ      r1,|L1.580|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;523      
;;;524      if (NewState != DISABLE)
;;;525      {
;;;526        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;527        USARTx->CR1 |= CR1_RWU_Set;
00023a  8982              LDRH     r2,[r0,#0xc]
00023c  f0420202          ORR      r2,r2,#2
000240  8182              STRH     r2,[r0,#0xc]
000242  e004              B        |L1.590|
                  |L1.580|
;;;528      }
;;;529      else
;;;530      {
;;;531        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;532        USARTx->CR1 &= CR1_RWU_Reset;
000244  8982              LDRH     r2,[r0,#0xc]
000246  f64f73fd          MOV      r3,#0xfffd
00024a  401a              ANDS     r2,r2,r3
00024c  8182              STRH     r2,[r0,#0xc]
                  |L1.590|
;;;533      }
;;;534    }
00024e  4770              BX       lr
;;;535    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;546      */
;;;547    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000250  8a02              LDRH     r2,[r0,#0x10]
;;;548    {
;;;549      /* Check the parameters */
;;;550      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;551      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;552      
;;;553      USARTx->CR2 &= CR2_LBDL_Mask;
000252  f64f73df          MOV      r3,#0xffdf
000256  401a              ANDS     r2,r2,r3
000258  8202              STRH     r2,[r0,#0x10]
;;;554      USARTx->CR2 |= USART_LINBreakDetectLength;  
00025a  8a02              LDRH     r2,[r0,#0x10]
00025c  430a              ORRS     r2,r2,r1
00025e  8202              STRH     r2,[r0,#0x10]
;;;555    }
000260  4770              BX       lr
;;;556    
                          ENDP

                  USART_LINCmd PROC
;;;565      */
;;;566    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000262  b121              CBZ      r1,|L1.622|
;;;567    {
;;;568      /* Check the parameters */
;;;569      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;570      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;571      
;;;572      if (NewState != DISABLE)
;;;573      {
;;;574        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;575        USARTx->CR2 |= CR2_LINEN_Set;
000264  8a02              LDRH     r2,[r0,#0x10]
000266  f4424280          ORR      r2,r2,#0x4000
00026a  8202              STRH     r2,[r0,#0x10]
00026c  e004              B        |L1.632|
                  |L1.622|
;;;576      }
;;;577      else
;;;578      {
;;;579        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;580        USARTx->CR2 &= CR2_LINEN_Reset;
00026e  8a02              LDRH     r2,[r0,#0x10]
000270  f64b73ff          MOV      r3,#0xbfff
000274  401a              ANDS     r2,r2,r3
000276  8202              STRH     r2,[r0,#0x10]
                  |L1.632|
;;;581      }
;;;582    }
000278  4770              BX       lr
;;;583    
                          ENDP

                  USART_SendData PROC
;;;591      */
;;;592    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
00027a  f3c10208          UBFX     r2,r1,#0,#9
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;596      assert_param(IS_USART_DATA(Data)); 
;;;597        
;;;598      /* Transmit Data */
;;;599      USARTx->DR = (Data & (uint16_t)0x01FF);
00027e  8082              STRH     r2,[r0,#4]
;;;600    }
000280  4770              BX       lr
;;;601    
                          ENDP

                  USART_ReceiveData PROC
;;;608      */
;;;609    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000282  4601              MOV      r1,r0
;;;610    {
;;;611      /* Check the parameters */
;;;612      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;613      
;;;614      /* Receive Data */
;;;615      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000284  8888              LDRH     r0,[r1,#4]
000286  f3c00008          UBFX     r0,r0,#0,#9
;;;616    }
00028a  4770              BX       lr
;;;617    
                          ENDP

                  USART_SendBreak PROC
;;;624      */
;;;625    void USART_SendBreak(USART_TypeDef* USARTx)
00028c  8981              LDRH     r1,[r0,#0xc]
;;;626    {
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;629      
;;;630      /* Send break characters */
;;;631      USARTx->CR1 |= CR1_SBK_Set;
00028e  f0410101          ORR      r1,r1,#1
000292  8181              STRH     r1,[r0,#0xc]
;;;632    }
000294  4770              BX       lr
;;;633    
                          ENDP

                  USART_SetGuardTime PROC
;;;640      */
;;;641    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000296  8b02              LDRH     r2,[r0,#0x18]
;;;642    {    
;;;643      /* Check the parameters */
;;;644      assert_param(IS_USART_123_PERIPH(USARTx));
;;;645      
;;;646      /* Clear the USART Guard time */
;;;647      USARTx->GTPR &= GTPR_LSB_Mask;
000298  b2d2              UXTB     r2,r2
00029a  8302              STRH     r2,[r0,#0x18]
;;;648      /* Set the USART guard time */
;;;649      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
00029c  8b02              LDRH     r2,[r0,#0x18]
00029e  ea422201          ORR      r2,r2,r1,LSL #8
0002a2  8302              STRH     r2,[r0,#0x18]
;;;650    }
0002a4  4770              BX       lr
;;;651    
                          ENDP

                  USART_SetPrescaler PROC
;;;660      */
;;;661    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
0002a6  8b02              LDRH     r2,[r0,#0x18]
;;;662    { 
;;;663      /* Check the parameters */
;;;664      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;665      
;;;666      /* Clear the USART prescaler */
;;;667      USARTx->GTPR &= GTPR_MSB_Mask;
0002a8  f402427f          AND      r2,r2,#0xff00
0002ac  8302              STRH     r2,[r0,#0x18]
;;;668      /* Set the USART prescaler */
;;;669      USARTx->GTPR |= USART_Prescaler;
0002ae  8b02              LDRH     r2,[r0,#0x18]
0002b0  430a              ORRS     r2,r2,r1
0002b2  8302              STRH     r2,[r0,#0x18]
;;;670    }
0002b4  4770              BX       lr
;;;671    
                          ENDP

                  USART_SmartCardCmd PROC
;;;679      */
;;;680    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002b6  b121              CBZ      r1,|L1.706|
;;;681    {
;;;682      /* Check the parameters */
;;;683      assert_param(IS_USART_123_PERIPH(USARTx));
;;;684      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;685      if (NewState != DISABLE)
;;;686      {
;;;687        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;688        USARTx->CR3 |= CR3_SCEN_Set;
0002b8  8a82              LDRH     r2,[r0,#0x14]
0002ba  f0420220          ORR      r2,r2,#0x20
0002be  8282              STRH     r2,[r0,#0x14]
0002c0  e004              B        |L1.716|
                  |L1.706|
;;;689      }
;;;690      else
;;;691      {
;;;692        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;693        USARTx->CR3 &= CR3_SCEN_Reset;
0002c2  8a82              LDRH     r2,[r0,#0x14]
0002c4  f64f73df          MOV      r3,#0xffdf
0002c8  401a              ANDS     r2,r2,r3
0002ca  8282              STRH     r2,[r0,#0x14]
                  |L1.716|
;;;694      }
;;;695    }
0002cc  4770              BX       lr
;;;696    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;704      */
;;;705    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002ce  b121              CBZ      r1,|L1.730|
;;;706    {
;;;707      /* Check the parameters */
;;;708      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;710      if (NewState != DISABLE)
;;;711      {
;;;712        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;713        USARTx->CR3 |= CR3_NACK_Set;
0002d0  8a82              LDRH     r2,[r0,#0x14]
0002d2  f0420210          ORR      r2,r2,#0x10
0002d6  8282              STRH     r2,[r0,#0x14]
0002d8  e004              B        |L1.740|
                  |L1.730|
;;;714      }
;;;715      else
;;;716      {
;;;717        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;718        USARTx->CR3 &= CR3_NACK_Reset;
0002da  8a82              LDRH     r2,[r0,#0x14]
0002dc  f64f73ef          MOV      r3,#0xffef
0002e0  401a              ANDS     r2,r2,r3
0002e2  8282              STRH     r2,[r0,#0x14]
                  |L1.740|
;;;719      }
;;;720    }
0002e4  4770              BX       lr
;;;721    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;730      */
;;;731    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002e6  b121              CBZ      r1,|L1.754|
;;;732    {
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;736      
;;;737      if (NewState != DISABLE)
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
0002e8  8a82              LDRH     r2,[r0,#0x14]
0002ea  f0420208          ORR      r2,r2,#8
0002ee  8282              STRH     r2,[r0,#0x14]
0002f0  e004              B        |L1.764|
                  |L1.754|
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
0002f2  8a82              LDRH     r2,[r0,#0x14]
0002f4  f64f73f7          MOV      r3,#0xfff7
0002f8  401a              ANDS     r2,r2,r3
0002fa  8282              STRH     r2,[r0,#0x14]
                  |L1.764|
;;;746      }
;;;747    }
0002fc  4770              BX       lr
;;;748    
                          ENDP

                  USART_OverSampling8Cmd PROC
;;;761      */
;;;762    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002fe  b121              CBZ      r1,|L1.778|
;;;763    {
;;;764      /* Check the parameters */
;;;765      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;766      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;767      
;;;768      if (NewState != DISABLE)
;;;769      {
;;;770        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;771        USARTx->CR1 |= CR1_OVER8_Set;
000300  8982              LDRH     r2,[r0,#0xc]
000302  f4424200          ORR      r2,r2,#0x8000
000306  8182              STRH     r2,[r0,#0xc]
000308  e003              B        |L1.786|
                  |L1.778|
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;776        USARTx->CR1 &= CR1_OVER8_Reset;
00030a  8982              LDRH     r2,[r0,#0xc]
00030c  f3c2020e          UBFX     r2,r2,#0,#15
000310  8182              STRH     r2,[r0,#0xc]
                  |L1.786|
;;;777      }
;;;778    }
000312  4770              BX       lr
;;;779    
                          ENDP

                  USART_OneBitMethodCmd PROC
;;;788      */
;;;789    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000314  b121              CBZ      r1,|L1.800|
;;;790    {
;;;791      /* Check the parameters */
;;;792      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;793      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;794      
;;;795      if (NewState != DISABLE)
;;;796      {
;;;797        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;798        USARTx->CR3 |= CR3_ONEBITE_Set;
000316  8a82              LDRH     r2,[r0,#0x14]
000318  f4426200          ORR      r2,r2,#0x800
00031c  8282              STRH     r2,[r0,#0x14]
00031e  e004              B        |L1.810|
                  |L1.800|
;;;799      }
;;;800      else
;;;801      {
;;;802        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;803        USARTx->CR3 &= CR3_ONEBITE_Reset;
000320  8a82              LDRH     r2,[r0,#0x14]
000322  f24f73ff          MOV      r3,#0xf7ff
000326  401a              ANDS     r2,r2,r3
000328  8282              STRH     r2,[r0,#0x14]
                  |L1.810|
;;;804      }
;;;805    }
00032a  4770              BX       lr
;;;806    
                          ENDP

                  USART_IrDAConfig PROC
;;;817      */
;;;818    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
00032c  8a82              LDRH     r2,[r0,#0x14]
;;;819    {
;;;820      /* Check the parameters */
;;;821      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;822      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;823        
;;;824      USARTx->CR3 &= CR3_IRLP_Mask;
00032e  f64f73fb          MOV      r3,#0xfffb
000332  401a              ANDS     r2,r2,r3
000334  8282              STRH     r2,[r0,#0x14]
;;;825      USARTx->CR3 |= USART_IrDAMode;
000336  8a82              LDRH     r2,[r0,#0x14]
000338  430a              ORRS     r2,r2,r1
00033a  8282              STRH     r2,[r0,#0x14]
;;;826    }
00033c  4770              BX       lr
;;;827    
                          ENDP

                  USART_IrDACmd PROC
;;;836      */
;;;837    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
00033e  b121              CBZ      r1,|L1.842|
;;;838    {
;;;839      /* Check the parameters */
;;;840      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;841      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;842        
;;;843      if (NewState != DISABLE)
;;;844      {
;;;845        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;846        USARTx->CR3 |= CR3_IREN_Set;
000340  8a82              LDRH     r2,[r0,#0x14]
000342  f0420202          ORR      r2,r2,#2
000346  8282              STRH     r2,[r0,#0x14]
000348  e004              B        |L1.852|
                  |L1.842|
;;;847      }
;;;848      else
;;;849      {
;;;850        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;851        USARTx->CR3 &= CR3_IREN_Reset;
00034a  8a82              LDRH     r2,[r0,#0x14]
00034c  f64f73fd          MOV      r3,#0xfffd
000350  401a              ANDS     r2,r2,r3
000352  8282              STRH     r2,[r0,#0x14]
                  |L1.852|
;;;852      }
;;;853    }
000354  4770              BX       lr
;;;854    
                          ENDP

                  USART_GetFlagStatus PROC
;;;873      */
;;;874    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000356  4602              MOV      r2,r0
;;;875    {
;;;876      FlagStatus bitstatus = RESET;
000358  2000              MOVS     r0,#0
;;;877      /* Check the parameters */
;;;878      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;879      assert_param(IS_USART_FLAG(USART_FLAG));
;;;880      /* The CTS flag is not available for UART4 and UART5 */
;;;881      if (USART_FLAG == USART_FLAG_CTS)
00035a  f5b17f00          CMP      r1,#0x200
00035e  d100              BNE      |L1.866|
;;;882      {
;;;883        assert_param(IS_USART_123_PERIPH(USARTx));
000360  bf00              NOP      
                  |L1.866|
;;;884      }  
;;;885      
;;;886      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000362  8813              LDRH     r3,[r2,#0]
000364  420b              TST      r3,r1
000366  d001              BEQ      |L1.876|
;;;887      {
;;;888        bitstatus = SET;
000368  2001              MOVS     r0,#1
00036a  e000              B        |L1.878|
                  |L1.876|
;;;889      }
;;;890      else
;;;891      {
;;;892        bitstatus = RESET;
00036c  2000              MOVS     r0,#0
                  |L1.878|
;;;893      }
;;;894      return bitstatus;
;;;895    }
00036e  4770              BX       lr
;;;896    
                          ENDP

                  USART_ClearFlag PROC
;;;922      */
;;;923    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000370  f4017200          AND      r2,r1,#0x200
;;;924    {
;;;925      /* Check the parameters */
;;;926      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;927      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;928      /* The CTS flag is not available for UART4 and UART5 */
;;;929      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000374  f5b27f00          CMP      r2,#0x200
000378  d100              BNE      |L1.892|
;;;930      {
;;;931        assert_param(IS_USART_123_PERIPH(USARTx));
00037a  bf00              NOP      
                  |L1.892|
;;;932      } 
;;;933       
;;;934      USARTx->SR = (uint16_t)~USART_FLAG;
00037c  43ca              MVNS     r2,r1
00037e  8002              STRH     r2,[r0,#0]
;;;935    }
000380  4770              BX       lr
;;;936    
                          ENDP

                  USART_GetITStatus PROC
;;;955      */
;;;956    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000382  b570              PUSH     {r4-r6,lr}
;;;957    {
000384  4602              MOV      r2,r0
;;;958      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000386  2300              MOVS     r3,#0
000388  2400              MOVS     r4,#0
00038a  2500              MOVS     r5,#0
;;;959      ITStatus bitstatus = RESET;
00038c  2000              MOVS     r0,#0
;;;960      /* Check the parameters */
;;;961      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;962      assert_param(IS_USART_GET_IT(USART_IT));
;;;963      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;964      if (USART_IT == USART_IT_CTS)
00038e  f5a16610          SUB      r6,r1,#0x900
000392  3e6a              SUBS     r6,r6,#0x6a
000394  d100              BNE      |L1.920|
;;;965      {
;;;966        assert_param(IS_USART_123_PERIPH(USARTx));
000396  bf00              NOP      
                  |L1.920|
;;;967      }   
;;;968      
;;;969      /* Get the USART register index */
;;;970      usartreg = (((uint8_t)USART_IT) >> 0x05);
000398  f3c11542          UBFX     r5,r1,#5,#3
;;;971      /* Get the interrupt position */
;;;972      itmask = USART_IT & IT_Mask;
00039c  f001041f          AND      r4,r1,#0x1f
;;;973      itmask = (uint32_t)0x01 << itmask;
0003a0  2601              MOVS     r6,#1
0003a2  fa06f404          LSL      r4,r6,r4
;;;974      
;;;975      if (usartreg == 0x01) /* The IT  is in CR1 register */
0003a6  2d01              CMP      r5,#1
0003a8  d102              BNE      |L1.944|
;;;976      {
;;;977        itmask &= USARTx->CR1;
0003aa  8996              LDRH     r6,[r2,#0xc]
0003ac  4034              ANDS     r4,r4,r6
0003ae  e006              B        |L1.958|
                  |L1.944|
;;;978      }
;;;979      else if (usartreg == 0x02) /* The IT  is in CR2 register */
0003b0  2d02              CMP      r5,#2
0003b2  d102              BNE      |L1.954|
;;;980      {
;;;981        itmask &= USARTx->CR2;
0003b4  8a16              LDRH     r6,[r2,#0x10]
0003b6  4034              ANDS     r4,r4,r6
0003b8  e001              B        |L1.958|
                  |L1.954|
;;;982      }
;;;983      else /* The IT  is in CR3 register */
;;;984      {
;;;985        itmask &= USARTx->CR3;
0003ba  8a96              LDRH     r6,[r2,#0x14]
0003bc  4034              ANDS     r4,r4,r6
                  |L1.958|
;;;986      }
;;;987      
;;;988      bitpos = USART_IT >> 0x08;
0003be  120b              ASRS     r3,r1,#8
;;;989      bitpos = (uint32_t)0x01 << bitpos;
0003c0  2601              MOVS     r6,#1
0003c2  fa06f303          LSL      r3,r6,r3
;;;990      bitpos &= USARTx->SR;
0003c6  8816              LDRH     r6,[r2,#0]
0003c8  4033              ANDS     r3,r3,r6
;;;991      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
0003ca  b114              CBZ      r4,|L1.978|
0003cc  b10b              CBZ      r3,|L1.978|
;;;992      {
;;;993        bitstatus = SET;
0003ce  2001              MOVS     r0,#1
0003d0  e000              B        |L1.980|
                  |L1.978|
;;;994      }
;;;995      else
;;;996      {
;;;997        bitstatus = RESET;
0003d2  2000              MOVS     r0,#0
                  |L1.980|
;;;998      }
;;;999      
;;;1000     return bitstatus;  
;;;1001   }
0003d4  bd70              POP      {r4-r6,pc}
;;;1002   
                          ENDP

                  USART_ClearITPendingBit PROC
;;;1029     */
;;;1030   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
0003d6  b510              PUSH     {r4,lr}
;;;1031   {
;;;1032     uint16_t bitpos = 0x00, itmask = 0x00;
0003d8  2200              MOVS     r2,#0
0003da  2300              MOVS     r3,#0
;;;1033     /* Check the parameters */
;;;1034     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1035     assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;1036     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1037     if (USART_IT == USART_IT_CTS)
0003dc  f5a16410          SUB      r4,r1,#0x900
0003e0  3c6a              SUBS     r4,r4,#0x6a
0003e2  d100              BNE      |L1.998|
;;;1038     {
;;;1039       assert_param(IS_USART_123_PERIPH(USARTx));
0003e4  bf00              NOP      
                  |L1.998|
;;;1040     }   
;;;1041     
;;;1042     bitpos = USART_IT >> 0x08;
0003e6  120a              ASRS     r2,r1,#8
;;;1043     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
0003e8  2401              MOVS     r4,#1
0003ea  4094              LSLS     r4,r4,r2
0003ec  b2a3              UXTH     r3,r4
;;;1044     USARTx->SR = (uint16_t)~itmask;
0003ee  43dc              MVNS     r4,r3
0003f0  8004              STRH     r4,[r0,#0]
;;;1045   }
0003f2  bd10              POP      {r4,pc}
                  |L1.1012|
                          DCD      0x40013800
                  |L1.1016|
                          DCD      0x40004400
                  |L1.1020|
                          DCD      0x40004800
                  |L1.1024|
                          DCD      0x40004c00
                  |L1.1028|
                          DCD      0x40005000
                          ENDP

