; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\usart.o --depend=..\OBJ\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\USER\INC -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\usart.crf ..\..\USER\SRC\USART.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;61     #pragma import(__use_no_semihosting) 
;;;62     _sys_exit(int x) 
000000  4601              MOV      r1,r0
;;;63     { 
;;;64     x = x; 
000002  bf00              NOP      
;;;65     } 
000004  4770              BX       lr
;;;66     struct __FILE 
                          ENDP

                  fputc PROC
;;;81       */
;;;82     PUTCHAR_PROTOTYPE
000006  b570              PUSH     {r4-r6,lr}
;;;83     {
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
;;;84       	/* Place your implementation of fputc here */
;;;85       	/* e.g. write a character to the USART */
;;;86       
;;;87       	/* Loop until the end of transmission */
;;;88       	while (USART_GetFlagStatus(USART_COM1, USART_FLAG_TC) == RESET)
00000c  bf00              NOP      
                  |L1.14|
00000e  2140              MOVS     r1,#0x40
000010  48fd              LDR      r0,|L1.1032|
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L1.14|
;;;89       	{}
;;;90      	USART_SendData(USART_COM1, (uint8_t) ch);
00001a  b2e1              UXTB     r1,r4
00001c  48fa              LDR      r0,|L1.1032|
00001e  f7fffffe          BL       USART_SendData
;;;91       	return ch;
000022  4620              MOV      r0,r4
;;;92     }
000024  bd70              POP      {r4-r6,pc}
;;;93     ////////////////////////////////////////////////////
                          ENDP

                  USART_NvicCfg PROC
;;;95     ////////////////////////////////////////////////////////////////////////////////
;;;96     static void USART_NvicCfg(uint16_t IRQn, uint8_t prio)
000026  b538              PUSH     {r3-r5,lr}
;;;97     {
000028  4604              MOV      r4,r0
00002a  460d              MOV      r5,r1
;;;98     	NVIC_InitTypeDef NVIC_InitStructure;
;;;99     
;;;100      	/* Configure the NVIC Preemption Priority Bits */  
;;;101       	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
;;;102    	
;;;103    	/* Enable the USARTz Interrupt */
;;;104      	NVIC_InitStructure.NVIC_IRQChannel = IRQn;
00002c  b2e0              UXTB     r0,r4
00002e  f88d0000          STRB     r0,[sp,#0]
;;;105    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = USART_NVIC_PREE_PRI;	//抢占优先级
000032  2000              MOVS     r0,#0
000034  f88d0001          STRB     r0,[sp,#1]
;;;106        NVIC_InitStructure.NVIC_IRQChannelSubPriority = prio;						//响应优先级
000038  f88d5002          STRB     r5,[sp,#2]
;;;107       	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003c  2001              MOVS     r0,#1
00003e  f88d0003          STRB     r0,[sp,#3]
;;;108      	NVIC_Init(&NVIC_InitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;109    }
000048  bd38              POP      {r3-r5,pc}
;;;110    
                          ENDP

                  USART_HardwareInit PROC
;;;111    static void USART_HardwareInit(COM_TypeDef COM, USART_InitTypeDef* USART_InitStruct)
00004a  b538              PUSH     {r3-r5,lr}
;;;112    {
00004c  4604              MOV      r4,r0
00004e  460d              MOV      r5,r1
;;;113    	GPIO_InitTypeDef GPIO_InitStructure;
;;;114    	
;;;115    	//初始化NVIC
;;;116    	USART_NvicCfg(COM_IRQn[COM], COM_Priority[COM]);	
000050  4aee              LDR      r2,|L1.1036|
000052  5d11              LDRB     r1,[r2,r4]
000054  4aee              LDR      r2,|L1.1040|
000056  f8320014          LDRH     r0,[r2,r4,LSL #1]
00005a  f7fffffe          BL       USART_NvicCfg
;;;117    	
;;;118    	//端口初始化,
;;;119    	// Enable GPIO clock ,AFIO时钟只有在使用USART3重映射时才开启->RCC_APB2Periph_AFIO
;;;120    	RCC_APB2PeriphClockCmd(COM_TX_PORT_CLK[COM] | COM_RX_PORT_CLK[COM], ENABLE);
00005e  49ed              LDR      r1,|L1.1044|
000060  f8511024          LDR      r1,[r1,r4,LSL #2]
000064  4aec              LDR      r2,|L1.1048|
000066  f8522024          LDR      r2,[r2,r4,LSL #2]
00006a  ea410002          ORR      r0,r1,r2
00006e  2101              MOVS     r1,#1
000070  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121    	
;;;122    	//USART时钟使能 Enable UART clock 
;;;123    	if (COM == COM1)
000074  b934              CBNZ     r4,|L1.132|
;;;124    	{	//USART1  为APB2
;;;125    		RCC_APB2PeriphClockCmd(COM_USART_CLK[COM], ENABLE); 
000076  49e9              LDR      r1,|L1.1052|
000078  f8510024          LDR      r0,[r1,r4,LSL #2]
00007c  2101              MOVS     r1,#1
00007e  f7fffffe          BL       RCC_APB2PeriphClockCmd
000082  e005              B        |L1.144|
                  |L1.132|
;;;126    	}
;;;127    	else
;;;128    	{	//USART2-3为APB1
;;;129    		RCC_APB1PeriphClockCmd(COM_USART_CLK[COM], ENABLE);
000084  49e5              LDR      r1,|L1.1052|
000086  f8510024          LDR      r0,[r1,r4,LSL #2]
00008a  2101              MOVS     r1,#1
00008c  f7fffffe          BL       RCC_APB1PeriphClockCmd
                  |L1.144|
;;;130    	}
;;;131    	
;;;132    	//配置USART Tx端口 Configure USART Tx as alternate function push-pull
;;;133    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000090  2018              MOVS     r0,#0x18
000092  f88d0003          STRB     r0,[sp,#3]
;;;134    	GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
000096  48e2              LDR      r0,|L1.1056|
000098  f8300014          LDRH     r0,[r0,r4,LSL #1]
00009c  f8ad0000          STRH     r0,[sp,#0]
;;;135    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a0  2003              MOVS     r0,#3
0000a2  f88d0002          STRB     r0,[sp,#2]
;;;136    	GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
0000a6  49df              LDR      r1,|L1.1060|
0000a8  f8510024          LDR      r0,[r1,r4,LSL #2]
0000ac  4669              MOV      r1,sp
0000ae  f7fffffe          BL       GPIO_Init
;;;137    	
;;;138    	//配置USART Rx端口 Configure USART Rx as input floating 
;;;139    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000b2  2004              MOVS     r0,#4
0000b4  f88d0003          STRB     r0,[sp,#3]
;;;140    	GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
0000b8  48db              LDR      r0,|L1.1064|
0000ba  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000be  f8ad0000          STRH     r0,[sp,#0]
;;;141    	GPIO_Init(COM_RX_PORT[COM], &GPIO_InitStructure);
0000c2  49d8              LDR      r1,|L1.1060|
0000c4  3108              ADDS     r1,r1,#8
0000c6  f8510024          LDR      r0,[r1,r4,LSL #2]
0000ca  4669              MOV      r1,sp
0000cc  f7fffffe          BL       GPIO_Init
;;;142    	
;;;143    	
;;;144    		
;;;145    	//USART初始化
;;;146    	USART_Init(COM_USART[COM], USART_InitStruct);
0000d0  49d4              LDR      r1,|L1.1060|
0000d2  3908              SUBS     r1,r1,#8
0000d4  f8510024          LDR      r0,[r1,r4,LSL #2]
0000d8  4629              MOV      r1,r5
0000da  f7fffffe          BL       USART_Init
;;;147    	
;;;148    	//接收中断使能
;;;149      	USART_ITConfig(COM_USART[COM], USART_IT_RXNE, ENABLE);
0000de  49d1              LDR      r1,|L1.1060|
0000e0  3908              SUBS     r1,r1,#8
0000e2  f8510024          LDR      r0,[r1,r4,LSL #2]
0000e6  2201              MOVS     r2,#1
0000e8  f2405125          MOV      r1,#0x525
0000ec  f7fffffe          BL       USART_ITConfig
;;;150       	//USART_ITConfig(USART_COM1, USART_IT_TXE, ENABLE);
;;;151    	
;;;152    	//使能USART
;;;153    	USART_Cmd(COM_USART[COM], ENABLE);
0000f0  49cc              LDR      r1,|L1.1060|
0000f2  3908              SUBS     r1,r1,#8
0000f4  f8510024          LDR      r0,[r1,r4,LSL #2]
0000f8  2101              MOVS     r1,#1
0000fa  f7fffffe          BL       USART_Cmd
;;;154    }
0000fe  bd38              POP      {r3-r5,pc}
;;;155    void USART_SendChar(COM_TypeDef COM, u8 ch_data)
                          ENDP

                  USART_SendChar PROC
000100  b570              PUSH     {r4-r6,lr}
;;;156    {
000102  4604              MOV      r4,r0
000104  460d              MOV      r5,r1
;;;157      	/* Loop until the end of transmission */
;;;158      	while (USART_GetFlagStatus(COM_USART[COM], USART_FLAG_TC) == RESET)
000106  bf00              NOP      
                  |L1.264|
000108  49c6              LDR      r1,|L1.1060|
00010a  3908              SUBS     r1,r1,#8
00010c  f8510024          LDR      r0,[r1,r4,LSL #2]
000110  2140              MOVS     r1,#0x40
000112  f7fffffe          BL       USART_GetFlagStatus
000116  2800              CMP      r0,#0
000118  d0f6              BEQ      |L1.264|
;;;159      	{
;;;160    		;
;;;161    	}
;;;162    	USART_SendData(COM_USART[COM], (u8)ch_data);
00011a  49c2              LDR      r1,|L1.1060|
00011c  3908              SUBS     r1,r1,#8
00011e  f8510024          LDR      r0,[r1,r4,LSL #2]
000122  4629              MOV      r1,r5
000124  f7fffffe          BL       USART_SendData
;;;163    }
000128  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP

                  USART1_Init PROC
;;;165    void USART1_Init(u32 baud_rate)
00012a  b51f              PUSH     {r0-r4,lr}
;;;166    {
00012c  4604              MOV      r4,r0
;;;167    	/* USARTx configured as follow:
;;;168            - BaudRate = baud_rate baud  
;;;169            - 8位 Word Length = 8 Bits
;;;170            - 1位停止位 One Stop Bit
;;;171            - No parity
;;;172            - Hardware flow control disabled (RTS and CTS signals)
;;;173            - Receive and transmit enabled
;;;174      	*/
;;;175    	USART_InitTypeDef USART_InitStructure;
;;;176    	
;;;177    	USART_InitStructure.USART_BaudRate = baud_rate;
00012e  9400              STR      r4,[sp,#0]
;;;178      	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000130  2000              MOVS     r0,#0
000132  f8ad0004          STRH     r0,[sp,#4]
;;;179      	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000136  f8ad0006          STRH     r0,[sp,#6]
;;;180      	USART_InitStructure.USART_Parity = USART_Parity_No;
00013a  f8ad0008          STRH     r0,[sp,#8]
;;;181      	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00013e  f8ad000c          STRH     r0,[sp,#0xc]
;;;182      	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000142  200c              MOVS     r0,#0xc
000144  f8ad000a          STRH     r0,[sp,#0xa]
;;;183    
;;;184      	USART_HardwareInit(COM1, &USART_InitStructure);
000148  4669              MOV      r1,sp
00014a  2000              MOVS     r0,#0
00014c  f7fffffe          BL       USART_HardwareInit
;;;185    }
000150  bd1f              POP      {r0-r4,pc}
;;;186    void USART2_Init(u32 baud_rate)
                          ENDP

                  USART2_Init PROC
000152  b51f              PUSH     {r0-r4,lr}
;;;187    {
000154  4604              MOV      r4,r0
;;;188    	/* USARTx configured as follow:
;;;189            - BaudRate = baud_rate baud  
;;;190            - 8位 Word Length = 8 Bits
;;;191            - 1位停止位 One Stop Bit
;;;192            - No parity
;;;193            - Hardware flow control disabled (RTS and CTS signals)
;;;194            - Receive and transmit enabled
;;;195      */
;;;196    	USART_InitTypeDef USART_InitStructure;
;;;197    	
;;;198    	USART_InitStructure.USART_BaudRate = baud_rate;
000156  9400              STR      r4,[sp,#0]
;;;199      	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000158  2000              MOVS     r0,#0
00015a  f8ad0004          STRH     r0,[sp,#4]
;;;200      	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00015e  f8ad0006          STRH     r0,[sp,#6]
;;;201      	USART_InitStructure.USART_Parity = USART_Parity_No;
000162  f8ad0008          STRH     r0,[sp,#8]
;;;202      	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000166  f8ad000c          STRH     r0,[sp,#0xc]
;;;203      	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00016a  200c              MOVS     r0,#0xc
00016c  f8ad000a          STRH     r0,[sp,#0xa]
;;;204    
;;;205      	USART_HardwareInit(COM2, &USART_InitStructure);
000170  4669              MOV      r1,sp
000172  2001              MOVS     r0,#1
000174  f7fffffe          BL       USART_HardwareInit
;;;206    }
000178  bd1f              POP      {r0-r4,pc}
;;;207    
                          ENDP

                  USART1_RxIntHandler PROC
;;;214    /////////////////////////////////////////////////////////////////////////////////////////////
;;;215    void USART1_RxIntHandler(void)
00017a  b510              PUSH     {r4,lr}
;;;216    {
;;;217    	if(USART_GetITStatus(USART_COM1, USART_IT_RXNE) != RESET)
00017c  f2405125          MOV      r1,#0x525
000180  48a1              LDR      r0,|L1.1032|
000182  f7fffffe          BL       USART_GetITStatus
000186  b138              CBZ      r0,|L1.408|
;;;218    	{
;;;219    		//Read one byte from the receive data register 
;;;220    		COM1_RxBuff[Index] = USART_ReceiveData(USART_COM1);
000188  489f              LDR      r0,|L1.1032|
00018a  f7fffffe          BL       USART_ReceiveData
00018e  49a7              LDR      r1,|L1.1068|
000190  4aa4              LDR      r2,|L1.1060|
000192  3210              ADDS     r2,r2,#0x10
000194  7812              LDRB     r2,[r2,#0]  ; Index
000196  5488              STRB     r0,[r1,r2]
                  |L1.408|
;;;221    
;;;222    	}
;;;223    	if(Index < Frame_Length)
000198  48a2              LDR      r0,|L1.1060|
00019a  3010              ADDS     r0,r0,#0x10
00019c  7800              LDRB     r0,[r0,#0]  ; Index
00019e  49a1              LDR      r1,|L1.1060|
0001a0  3111              ADDS     r1,r1,#0x11
0001a2  7809              LDRB     r1,[r1,#0]  ; Frame_Length
0001a4  4288              CMP      r0,r1
0001a6  da06              BGE      |L1.438|
;;;224    	{
;;;225    		Index ++;
0001a8  489e              LDR      r0,|L1.1060|
0001aa  3010              ADDS     r0,r0,#0x10
0001ac  7800              LDRB     r0,[r0,#0]  ; Index
0001ae  1c40              ADDS     r0,r0,#1
0001b0  499c              LDR      r1,|L1.1060|
0001b2  3110              ADDS     r1,r1,#0x10
0001b4  7008              STRB     r0,[r1,#0]
                  |L1.438|
;;;226    	}
;;;227    
;;;228    }
0001b6  bd10              POP      {r4,pc}
;;;229    void USART2_RxIntHandler(void)
                          ENDP

                  USART2_RxIntHandler PROC
0001b8  b510              PUSH     {r4,lr}
;;;230    {
;;;231    	if(USART_GetITStatus(USART_COM2, USART_IT_RXNE) != RESET)
0001ba  f2405125          MOV      r1,#0x525
0001be  489c              LDR      r0,|L1.1072|
0001c0  f7fffffe          BL       USART_GetITStatus
0001c4  b170              CBZ      r0,|L1.484|
;;;232    	{
;;;233    
;;;234    		RxBuffer2[RxCounter2++] = USART_ReceiveData(USART_COM2);
0001c6  489a              LDR      r0,|L1.1072|
0001c8  f7fffffe          BL       USART_ReceiveData
0001cc  b2c1              UXTB     r1,r0
0001ce  4895              LDR      r0,|L1.1060|
0001d0  3012              ADDS     r0,r0,#0x12
0001d2  7802              LDRB     r2,[r0,#0]  ; RxCounter2
0001d4  7800              LDRB     r0,[r0,#0]  ; RxCounter2
0001d6  1c40              ADDS     r0,r0,#1
0001d8  4b92              LDR      r3,|L1.1060|
0001da  3312              ADDS     r3,r3,#0x12
0001dc  7018              STRB     r0,[r3,#0]
0001de  4893              LDR      r0,|L1.1068|
0001e0  301e              ADDS     r0,r0,#0x1e
0001e2  5481              STRB     r1,[r0,r2]
                  |L1.484|
;;;235    	}
;;;236    	
;;;237    }
0001e4  bd10              POP      {r4,pc}
;;;238    void USART1_Transmit(u8 ch_data)
                          ENDP

                  USART1_Transmit PROC
0001e6  b510              PUSH     {r4,lr}
;;;239    {
0001e8  4604              MOV      r4,r0
;;;240    	// Loop until the end of transmission
;;;241      	while (USART_GetFlagStatus(USART_COM1, USART_FLAG_TC) == RESET)
0001ea  bf00              NOP      
                  |L1.492|
0001ec  2140              MOVS     r1,#0x40
0001ee  4886              LDR      r0,|L1.1032|
0001f0  f7fffffe          BL       USART_GetFlagStatus
0001f4  2800              CMP      r0,#0
0001f6  d0f9              BEQ      |L1.492|
;;;242      	{
;;;243    		;
;;;244    	}
;;;245    	USART_SendData(USART_COM1, (u8)ch_data);
0001f8  4621              MOV      r1,r4
0001fa  4883              LDR      r0,|L1.1032|
0001fc  f7fffffe          BL       USART_SendData
;;;246    }
000200  bd10              POP      {r4,pc}
;;;247    
                          ENDP

                  USART2_Transmit PROC
;;;248    void USART2_Transmit(u8 ch_data)
000202  b510              PUSH     {r4,lr}
;;;249    {
000204  4604              MOV      r4,r0
;;;250    	// Loop until the end of transmission 
;;;251      	while (USART_GetFlagStatus(USART_COM2, USART_FLAG_TC) == RESET)
000206  bf00              NOP      
                  |L1.520|
000208  2140              MOVS     r1,#0x40
00020a  4889              LDR      r0,|L1.1072|
00020c  f7fffffe          BL       USART_GetFlagStatus
000210  2800              CMP      r0,#0
000212  d0f9              BEQ      |L1.520|
;;;252      	{
;;;253    		;
;;;254    	}
;;;255    	USART_SendData(USART_COM2, (u8)ch_data);
000214  4621              MOV      r1,r4
000216  4886              LDR      r0,|L1.1072|
000218  f7fffffe          BL       USART_SendData
;;;256    }
00021c  bd10              POP      {r4,pc}
;;;257    
                          ENDP

                  USART_Debug PROC
;;;258    //////////////////////////////上层应用函数/////////////////////////////////////
;;;259    void USART_Debug(u8 debug_data)
00021e  b510              PUSH     {r4,lr}
;;;260    {
000220  4604              MOV      r4,r0
;;;261    	USART_Transmit(0xaa);
000222  20aa              MOVS     r0,#0xaa
000224  f7fffffe          BL       USART1_Transmit
;;;262    	USART_Transmit(debug_data);
000228  4620              MOV      r0,r4
00022a  f7fffffe          BL       USART1_Transmit
;;;263    	USART_Transmit(0x55);
00022e  2055              MOVS     r0,#0x55
000230  f7fffffe          BL       USART1_Transmit
;;;264    }
000234  bd10              POP      {r4,pc}
;;;265    void USART_SendLine(s32 Data ,
                          ENDP

                  USART_SendLine PROC
000236  e92d5ff0          PUSH     {r4-r12,lr}
;;;266    					u8 Is_H, 
;;;267    				    u8 Line_ID)
;;;268    {
00023a  4604              MOV      r4,r0
00023c  460d              MOV      r5,r1
00023e  4616              MOV      r6,r2
;;;269    	u8 Temp_A_L;				
;;;270    	u8 Temp_A_H;
;;;271    	u8 Temp_B_L;
;;;272    	s8 Temp_B_H;
;;;273    	
;;;274    	u8 ch_XOR = 0;
000240  f04f0b00          MOV      r11,#0
;;;275    	
;;;276    	Temp_A_L = Data;
000244  b2e7              UXTB     r7,r4
;;;277    	Temp_A_H = Data>>8;
000246  f3c42807          UBFX     r8,r4,#8,#8
;;;278    	Temp_B_L = Data >> 16;
00024a  f3c44907          UBFX     r9,r4,#16,#8
;;;279    	Temp_B_H = Data >> 24;
00024e  ea4f6a24          ASR      r10,r4,#24
;;;280    	
;;;281    	ch_XOR ^= 0x09;
000252  f08b0b09          EOR      r11,r11,#9
;;;282    	ch_XOR ^= Line_ID;
000256  ea8b0b06          EOR      r11,r11,r6
;;;283    	
;;;284    	ch_XOR ^= Temp_B_H;
00025a  ea8b000a          EOR      r0,r11,r10
00025e  f0000bff          AND      r11,r0,#0xff
;;;285    	ch_XOR ^= Temp_B_L;
000262  ea8b0b09          EOR      r11,r11,r9
;;;286    	ch_XOR ^= Temp_A_H;
000266  ea8b0b08          EOR      r11,r11,r8
;;;287    	ch_XOR ^= Temp_A_L;
00026a  ea8b0b07          EOR      r11,r11,r7
;;;288    	
;;;289    	USART_Transmit(0xaa);
00026e  20aa              MOVS     r0,#0xaa
000270  f7fffffe          BL       USART1_Transmit
;;;290    	USART_Transmit(0x09);
000274  2009              MOVS     r0,#9
000276  f7fffffe          BL       USART1_Transmit
;;;291    	USART_Transmit(Line_ID);
00027a  4630              MOV      r0,r6
00027c  f7fffffe          BL       USART1_Transmit
;;;292    	
;;;293    	if(Is_H)							//是否是先发高字节？					
000280  b16d              CBZ      r5,|L1.670|
;;;294    	{
;;;295    		USART_Transmit(Temp_B_H);		//是									
000282  f00a00ff          AND      r0,r10,#0xff
000286  f7fffffe          BL       USART1_Transmit
;;;296    		USART_Transmit(Temp_B_L);
00028a  4648              MOV      r0,r9
00028c  f7fffffe          BL       USART1_Transmit
;;;297    		USART_Transmit(Temp_A_H);
000290  4640              MOV      r0,r8
000292  f7fffffe          BL       USART1_Transmit
;;;298    		USART_Transmit(Temp_A_L);
000296  4638              MOV      r0,r7
000298  f7fffffe          BL       USART1_Transmit
00029c  e00c              B        |L1.696|
                  |L1.670|
;;;299    	}
;;;300    	else
;;;301    	{
;;;302    		USART_Transmit(Temp_A_L);		//不是									
00029e  4638              MOV      r0,r7
0002a0  f7fffffe          BL       USART1_Transmit
;;;303    		USART_Transmit(Temp_A_H);
0002a4  4640              MOV      r0,r8
0002a6  f7fffffe          BL       USART1_Transmit
;;;304    		USART_Transmit(Temp_B_L);
0002aa  4648              MOV      r0,r9
0002ac  f7fffffe          BL       USART1_Transmit
;;;305    		USART_Transmit(Temp_B_H);
0002b0  f00a00ff          AND      r0,r10,#0xff
0002b4  f7fffffe          BL       USART1_Transmit
                  |L1.696|
;;;306    	}
;;;307    	
;;;308    	USART_Transmit(ch_XOR);
0002b8  4658              MOV      r0,r11
0002ba  f7fffffe          BL       USART1_Transmit
;;;309    	USART_Transmit(0x55);
0002be  2055              MOVS     r0,#0x55
0002c0  f7fffffe          BL       USART1_Transmit
;;;310    }
0002c4  e8bd9ff0          POP      {r4-r12,pc}
;;;311    void USART_SendString(unsigned char *p_STR)
                          ENDP

                  USART_SendString PROC
0002c8  b510              PUSH     {r4,lr}
;;;312    {
0002ca  4604              MOV      r4,r0
;;;313    	while(*p_STR)
0002cc  e003              B        |L1.726|
                  |L1.718|
;;;314    	{
;;;315    		USART_Transmit(*p_STR ++);
0002ce  f8140b01          LDRB     r0,[r4],#1
0002d2  f7fffffe          BL       USART1_Transmit
                  |L1.726|
0002d6  7820              LDRB     r0,[r4,#0]            ;313
0002d8  2800              CMP      r0,#0                 ;313
0002da  d1f8              BNE      |L1.718|
;;;316    	}
;;;317    }
0002dc  bd10              POP      {r4,pc}
;;;318    //////////////接收///////////////////
                          ENDP

                  USART_GetChar PROC
;;;319    u8 USART_GetChar(u8* p_array, u8 frame_len)
0002de  b510              PUSH     {r4,lr}
;;;320    {
0002e0  4602              MOV      r2,r0
;;;321    	u8 i = 0;
0002e2  2300              MOVS     r3,#0
;;;322    	if(Frame_Length != frame_len)
0002e4  484f              LDR      r0,|L1.1060|
0002e6  3011              ADDS     r0,r0,#0x11
0002e8  7800              LDRB     r0,[r0,#0]  ; Frame_Length
0002ea  4288              CMP      r0,r1
0002ec  d002              BEQ      |L1.756|
;;;323    	{
;;;324    		Frame_Length = frame_len;
0002ee  484d              LDR      r0,|L1.1060|
0002f0  3011              ADDS     r0,r0,#0x11
0002f2  7001              STRB     r1,[r0,#0]
                  |L1.756|
;;;325    	}
;;;326    	if(Index == Frame_Length)
0002f4  484b              LDR      r0,|L1.1060|
0002f6  3010              ADDS     r0,r0,#0x10
0002f8  7800              LDRB     r0,[r0,#0]  ; Index
0002fa  4c4a              LDR      r4,|L1.1060|
0002fc  3411              ADDS     r4,r4,#0x11
0002fe  7824              LDRB     r4,[r4,#0]  ; Frame_Length
000300  42a0              CMP      r0,r4
000302  d111              BNE      |L1.808|
;;;327    	{
;;;328    		for(i=0; i< Frame_Length; i++)
000304  2300              MOVS     r3,#0
000306  e004              B        |L1.786|
                  |L1.776|
;;;329    		{
;;;330    			p_array[i] = COM1_RxBuff[i];
000308  4848              LDR      r0,|L1.1068|
00030a  5cc0              LDRB     r0,[r0,r3]
00030c  54d0              STRB     r0,[r2,r3]
00030e  1c58              ADDS     r0,r3,#1              ;328
000310  b2c3              UXTB     r3,r0                 ;328
                  |L1.786|
000312  4844              LDR      r0,|L1.1060|
000314  3011              ADDS     r0,r0,#0x11           ;328
000316  7800              LDRB     r0,[r0,#0]            ;328  ; Frame_Length
000318  4283              CMP      r3,r0                 ;328
00031a  dbf5              BLT      |L1.776|
;;;331    		}
;;;332    		Index = 0;
00031c  2000              MOVS     r0,#0
00031e  4c41              LDR      r4,|L1.1060|
000320  3410              ADDS     r4,r4,#0x10
000322  7020              STRB     r0,[r4,#0]
;;;333    		return 1;
000324  2001              MOVS     r0,#1
                  |L1.806|
;;;334    	}
;;;335    	return 0;
;;;336    }
000326  bd10              POP      {r4,pc}
                  |L1.808|
000328  2000              MOVS     r0,#0                 ;335
00032a  e7fc              B        |L1.806|
;;;337    u8 USART_GetRate(s32* p_rate)
                          ENDP

                  USART_GetRate PROC
00032c  b57e              PUSH     {r1-r6,lr}
;;;338    {
00032e  4604              MOV      r4,r0
;;;339    	u8 temp_array[9] = {0};
000330  4668              MOV      r0,sp
000332  2100              MOVS     r1,#0
000334  460a              MOV      r2,r1
000336  460b              MOV      r3,r1
000338  c00e              STM      r0!,{r1-r3}
;;;340    	u8 i =0;										
00033a  2500              MOVS     r5,#0
;;;341    	s32 temp_rate = 0;
00033c  2600              MOVS     r6,#0
;;;342    	static u8 ch_cmd = 0;					//命令位用静态变量，保证数据能保持在
;;;343    											//上一次接收到的值（即不丢失）		
;;;344    	if(USART_GetChar(temp_array, 9))		//如果收到新数据才进行数据校验与恢复
00033e  2109              MOVS     r1,#9
000340  4668              MOV      r0,sp
000342  f7fffffe          BL       USART_GetChar
000346  b1c8              CBZ      r0,|L1.892|
;;;345    	{										//这样提高了查询速度				
;;;346    		if((temp_array[0] == 0xaa)&&(temp_array[8] == 0x55))
000348  f89d0000          LDRB     r0,[sp,#0]
00034c  28aa              CMP      r0,#0xaa
00034e  d115              BNE      |L1.892|
000350  f89d0008          LDRB     r0,[sp,#8]
000354  2855              CMP      r0,#0x55
000356  d111              BNE      |L1.892|
;;;347    		{
;;;348    			for(i = 3; i < 7; i ++)
000358  2503              MOVS     r5,#3
00035a  e007              B        |L1.876|
                  |L1.860|
;;;349    			{
;;;350    				temp_rate |= temp_array[i]<<((i-3)<<3);//8*(i-3)				
00035c  f81d0005          LDRB     r0,[sp,r5]
000360  1ee9              SUBS     r1,r5,#3
000362  00c9              LSLS     r1,r1,#3
000364  4088              LSLS     r0,r0,r1
000366  4306              ORRS     r6,r6,r0
000368  1c68              ADDS     r0,r5,#1              ;348
00036a  b2c5              UXTB     r5,r0                 ;348
                  |L1.876|
00036c  2d07              CMP      r5,#7                 ;348
00036e  dbf5              BLT      |L1.860|
;;;351    			}
;;;352    			ch_cmd = temp_array[2];			//获取命令位						
000370  f89d0002          LDRB     r0,[sp,#2]
000374  492b              LDR      r1,|L1.1060|
000376  3113              ADDS     r1,r1,#0x13
000378  7008              STRB     r0,[r1,#0]
;;;353    			*p_rate = temp_rate;			//获取数据位						
00037a  6026              STR      r6,[r4,#0]
                  |L1.892|
;;;354    		}
;;;355    	}
;;;356    	return ch_cmd;
00037c  4829              LDR      r0,|L1.1060|
00037e  3013              ADDS     r0,r0,#0x13
000380  7800              LDRB     r0,[r0,#0]  ; ch_cmd
;;;357    }
000382  bd7e              POP      {r1-r6,pc}
;;;358    
                          ENDP

                  Prints PROC
;;;369    ********************************************************************/
;;;370    void Prints(const u8 * pd)
000384  b510              PUSH     {r4,lr}
;;;371    {
000386  4604              MOV      r4,r0
;;;372    	while((*pd)!='\0') //发送字符串，直到遇到0才结束
000388  e003              B        |L1.914|
                  |L1.906|
;;;373    	{
;;;374    		UartPutChar(*pd); //发送一个字符
00038a  7820              LDRB     r0,[r4,#0]
00038c  f7fffffe          BL       USART1_Transmit
;;;375    		pd++;  //移动到下一个字符
000390  1c64              ADDS     r4,r4,#1
                  |L1.914|
000392  7820              LDRB     r0,[r4,#0]            ;372
000394  2800              CMP      r0,#0                 ;372
000396  d1f8              BNE      |L1.906|
;;;376    	}
;;;377    }
000398  bd10              POP      {r4,pc}
;;;378    ////////////////////////End of function//////////////////////////////
                          ENDP

                  PrintLongInt PROC
;;;384    ********************************************************************/
;;;385    void PrintLongInt(u32 x)
00039a  b53e              PUSH     {r1-r5,lr}
;;;386    {
00039c  4604              MOV      r4,r0
;;;387     	s8 i;
;;;388     	u8 display_buffer[10];
;;;389    
;;;390    	for(i=9;i>=0;i--)
00039e  2509              MOVS     r5,#9
0003a0  e00d              B        |L1.958|
                  |L1.930|
;;;391    	{
;;;392    		display_buffer[i]='0'+x%10;
0003a2  200a              MOVS     r0,#0xa
0003a4  fbb4f1f0          UDIV     r1,r4,r0
0003a8  fb004011          MLS      r0,r0,r1,r4
0003ac  3030              ADDS     r0,r0,#0x30
0003ae  b2c0              UXTB     r0,r0
0003b0  f80d0005          STRB     r0,[sp,r5]
;;;393    		x/=10;
0003b4  200a              MOVS     r0,#0xa
0003b6  fbb4f4f0          UDIV     r4,r4,r0
0003ba  1e68              SUBS     r0,r5,#1              ;390
0003bc  b245              SXTB     r5,r0                 ;390
                  |L1.958|
0003be  2d00              CMP      r5,#0                 ;390
0003c0  daef              BGE      |L1.930|
;;;394    	}
;;;395    	for(i=0;i<9;i++)
0003c2  2500              MOVS     r5,#0
0003c4  e006              B        |L1.980|
                  |L1.966|
;;;396    	{
;;;397    		if(display_buffer[i]!='0')
0003c6  f81d0005          LDRB     r0,[sp,r5]
0003ca  2830              CMP      r0,#0x30
0003cc  d000              BEQ      |L1.976|
;;;398    		{
;;;399    			break;	
0003ce  e003              B        |L1.984|
                  |L1.976|
0003d0  1c68              ADDS     r0,r5,#1              ;395
0003d2  b245              SXTB     r5,r0                 ;395
                  |L1.980|
0003d4  2d09              CMP      r5,#9                 ;395
0003d6  dbf6              BLT      |L1.966|
                  |L1.984|
0003d8  bf00              NOP      
;;;400    		}
;;;401    	}
;;;402    	for(;i<10;i++)
0003da  e005              B        |L1.1000|
                  |L1.988|
;;;403    	{
;;;404    		UartPutChar(display_buffer[i]);	
0003dc  f81d0005          LDRB     r0,[sp,r5]
0003e0  f7fffffe          BL       USART1_Transmit
0003e4  1c68              ADDS     r0,r5,#1              ;402
0003e6  b245              SXTB     r5,r0                 ;402
                  |L1.1000|
0003e8  2d0a              CMP      r5,#0xa               ;402
0003ea  dbf7              BLT      |L1.988|
;;;405    	}
;;;406    }
0003ec  bd3e              POP      {r1-r5,pc}
;;;407    ////////////////////////End of function//////////////////////////////
                          ENDP

                  PrintShortIntHex PROC
;;;414    ********************************************************************/
;;;415    void PrintShortIntHex(u16 x)
0003ee  b57c              PUSH     {r2-r6,lr}
;;;416    {
0003f0  4604              MOV      r4,r0
;;;417     	u8 i;
;;;418     	u8 display_buffer[7];
;;;419     	display_buffer[6]=0;
0003f2  2000              MOVS     r0,#0
0003f4  f88d0006          STRB     r0,[sp,#6]
;;;420     	display_buffer[0]='0';
0003f8  2030              MOVS     r0,#0x30
0003fa  f88d0000          STRB     r0,[sp,#0]
;;;421     	display_buffer[1]='x';
0003fe  2078              MOVS     r0,#0x78
000400  f88d0001          STRB     r0,[sp,#1]
;;;422     	for(i=5;i>=2;i--) //将整数转换为4个字节的HEX值
000404  2505              MOVS     r5,#5
000406  e01e              B        |L1.1094|
                  |L1.1032|
                          DCD      0x40013800
                  |L1.1036|
                          DCD      COM_Priority
                  |L1.1040|
                          DCD      COM_IRQn
                  |L1.1044|
                          DCD      COM_TX_PORT_CLK
                  |L1.1048|
                          DCD      COM_RX_PORT_CLK
                  |L1.1052|
                          DCD      COM_USART_CLK
                  |L1.1056|
                          DCD      COM_TX_PIN
                  |L1.1060|
                          DCD      ||.data||+0x8
                  |L1.1064|
                          DCD      COM_RX_PIN
                  |L1.1068|
                          DCD      ||.bss||
                  |L1.1072|
                          DCD      0x40004400
                  |L1.1076|
;;;423     	{
;;;424    	  	display_buffer[i]=HexTable[(x&0xf)];
000434  f004000f          AND      r0,r4,#0xf
000438  4912              LDR      r1,|L1.1156|
00043a  5c08              LDRB     r0,[r1,r0]
00043c  f80d0005          STRB     r0,[sp,r5]
;;;425    	  	x>>=4;
000440  1124              ASRS     r4,r4,#4
000442  1e68              SUBS     r0,r5,#1              ;422
000444  b2c5              UXTB     r5,r0                 ;422
                  |L1.1094|
000446  2d02              CMP      r5,#2                 ;422
000448  daf4              BGE      |L1.1076|
;;;426     	}
;;;427     	Prints(display_buffer);
00044a  4668              MOV      r0,sp
00044c  f7fffffe          BL       Prints
;;;428    }
000450  bd7c              POP      {r2-r6,pc}
;;;429    
                          ENDP

                  PrintHex PROC
;;;435    ********************************************************************/
;;;436    void PrintHex(u8 x)
000452  b510              PUSH     {r4,lr}
;;;437    {
000454  4604              MOV      r4,r0
;;;438    	Printc('0');
000456  2030              MOVS     r0,#0x30
000458  f7fffffe          BL       USART1_Transmit
;;;439    	Printc('x');
00045c  2078              MOVS     r0,#0x78
00045e  f7fffffe          BL       USART1_Transmit
;;;440    	Printc(HexTable[x>>4]);
000462  4908              LDR      r1,|L1.1156|
000464  eb011124          ADD      r1,r1,r4,ASR #4
000468  7808              LDRB     r0,[r1,#0]
00046a  f7fffffe          BL       USART1_Transmit
;;;441    	Printc(HexTable[x&0xf]);
00046e  f004010f          AND      r1,r4,#0xf
000472  4a04              LDR      r2,|L1.1156|
000474  5c50              LDRB     r0,[r2,r1]
000476  f7fffffe          BL       USART1_Transmit
;;;442    	Printc(' ');
00047a  2020              MOVS     r0,#0x20
00047c  f7fffffe          BL       USART1_Transmit
;;;443    }
000480  bd10              POP      {r4,pc}
;;;444    ////////////////////////End of function//////////////////////////////
                          ENDP

000482  0000              DCW      0x0000
                  |L1.1156|
                          DCD      HexTable

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  COM1_RxBuff
                          %        30
                  RxBuffer2
                          %        10

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  COM_USART_CLK
                          DCD      0x00004000
                          DCD      0x00020000
                  COM_TX_PORT_CLK
                          DCD      0x00000004
                          DCD      0x00000004
                  COM_RX_PORT_CLK
                          DCD      0x00000004
                          DCD      0x00000004
                  COM_TX_PIN
000018  02000004          DCW      0x0200,0x0004
                  COM_RX_PIN
00001c  04000008          DCW      0x0400,0x0008
                  COM_IRQn
000020  00250026          DCW      0x0025,0x0026
                  COM_Priority
000024  0001              DCB      0x00,0x01
                  HexTable
000026  3031              DCB      0x30,0x31
000028  32333435          DCB      0x32,0x33,0x34,0x35
00002c  36373839          DCB      0x36,0x37,0x38,0x39
000030  41424344          DCB      0x41,0x42,0x43,0x44
000034  4546              DCB      0x45,0x46

                          AREA ||.data||, DATA, ALIGN=2

                  COM_USART
                          DCD      0x40013800
                          DCD      0x40004400
                  COM_TX_PORT
                          DCD      0x40010800
                          DCD      0x40010800
                  COM_RX_PORT
                          DCD      0x40010800
                          DCD      0x40010800
                  Index
000018  00                DCB      0x00
                  Frame_Length
000019  00                DCB      0x00
                  RxCounter2
00001a  00                DCB      0x00
                  ch_cmd
00001b  00                DCB      0x00
                  __stdout
                          DCD      0x00000000
